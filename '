# frozen_string_literal: true

require_relative "nequi/version"

module Nequi
  class Error < StandardError; end
  require 'httparty'
  require 'base64'
  require 'json'
  require 'time'
  require 'active_support/core_ext/integer/time'

  include HTTParty

  class << self
    attr_accessor :configuration
  end

  def self.configure
    self.configuration ||= Configuration.new
    yield(configuration)
  end

  class Configuration
    attr_accessor :auth_uri, :phone, :auth_grant_type, :unregisteredpayment_endpoint,
                  :client_id, :client_secret, :api_base_path, :api_key
  end

  NEQUI_STATUS_CODE_SUCCESS = '200'.freeze

  def self.get_token
    return @token if @token

    headers = {
      'Content-Type' => 'application/x-www-form-urlencoded',
      'Accept' => 'application/json',
      'Authorization' => "Basic #{Base64.strict_encode64("#{configuration.client_id}:#{configuration.client_secret}")}"
    }

    body = { 'grant_type' => configuration.auth_grant_type }

    response = HTTParty.post(configuration.auth_uri, body: body, headers: headers)

    raise "Failed to authenticate with Nequi. HTTP status code: #{response.code}" unless (response.code.to_i == 200 && !response.body.empty?)

    response_body = JSON.parse(response.body)
    @token = { access_token: response_body['access_token'], token_type: response_body['token_type'], expires_at: Time.now + 15.minutes }
    ap @token
    @token
  end

  def self.payment_request(amount, phone, product_id)

    ap 'hello world'
    current_time = Time.now
    utc_time = current_time.utc
    formatted_timestamp = utc_time.strftime('%Y-%m-%dT%H:%M:%S.%LZ')

    headers = {
      'Content-Type' => 'application/json',
      'Accept' => 'application/json',
      'Authorization' => "Bearer #{get_token[:access_token]}",
      'x-api-key' => configuration.api_key
    }

    body = {
      "RequestMessage" => {
        "RequestHeader" => {
          "Channel" => "PNP04-C001",
          "RequestDate" => formatted_timestamp,
          "MessageID" => product_id,
          "ClientID" => configuration.client_id,
          "Destination" => {
          "ServiceName" => "PaymentsService",
          "ServiceOperation" => "unregisteredPayment",
            "ServiceRegion" => "C001",
            "ServiceVersion" => "1.2.0"
          }
        },
        "RequestBody" => {
          "any" => {
            "unregisteredPaymentRQ" => {
              "phoneNumber" => phone,
              "code" => "NIT_1",
              "value" => amount
            }
          }
        }
      }
    }.to_json

    logs = [{ 'type' => 'information', 'message' => "Ready to send Petitions" }]

    unregisteredpayment = configuration.api_base_path + configuration.unregisteredpayment_endpoint
    binding.pry
    response = HTTParty.post(unregisteredpayment, body: body, headers: headers)

    binding.pry
    response_body = JSON.parse(response.body)

    if response.code == 200 && !response_body['ResponseMessage']['ResponseBody'].nil?
      logs << { 'type' => 'information', 'message' => "Petition returned HTTP 200" }

      begin
        any_data = response_body['ResponseMessage']['ResponseBody']['any']

        status = response_body['ResponseMessage']['ResponseHeader']['Status']
        status_code = status ? status['StatusCode'] : ''
        status_desc = status ? status['StatusDesc'] : ''

        binding.pry
        if status_code == '200'
          payment = any_data['unregisteredPaymentRS']
          trn_id = payment ? payment['transactionId'].to_s.strip : ''

          #send a message 200 and base on that display a success message
          # message ="#{response["ResponseMessage"]["ResponseHeader"]["Status"]["StatusDesc"]}"
          # response.code ----> this is a 200 integer
          # like this one: Please go to the nequi application and accept the payment.
          # this message shold show in the same show action
          # I need to fix this case, this error is from nequi end.
          # "Status": {
          #"StatusCode": "20-07A",
          # "StatusDesc": "¡Error técnico!"
          # },
          # buyer has only 8 minutes to aprove, else need to send new charge request
          #status_check_job = StatusCheckJob.set(wait: 2.minutes).perform_later(product_id, configuration, @token[:access_token], code_qr) #---> I need this code_qr from the return request

          logs << { type: 'success',
                    status: 200,
                    message: 'Payment request send success fully',
                  }

        else
          raise 'Error ' + status_code + ' = ' + status_desc
        end

      rescue StandardError => e
        raise e
      end
    else
      raise 'Unable to connect to Nequi, please check the information sent.'
    end

    logs
  end
end
